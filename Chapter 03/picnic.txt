테스트 케이스의 수 c
첫줄에는 학생의 수 n와 친구 쌍의 수 m (0 <= m <= n(n-1)/2)
그 다음 줄에 m 개의 정수의 쌍

두명씩 짝지어서 모두가 짝이 되는 경우의 수를 구하는 것

여기서 더이상 쪼개질 수 없는 작업은?
base case : 모두가 짝이 지어졌을 때

분할해야하는 부분은 ? 

어떤 한 학생이 다른 학생을 고르는 작업
하지만 여기서 (0,1) 과 (1,0)이 같은 작업으로 보고 있음 이것은 중복으로 세기 때문에
해결법이 필요함. 그냥 오름차순으로 선택해서 설정하자!

필요한 전역 변수
학생의 수 n 과 서로 친구가 되어 있나 알 수 있는 조직도 --> 관계를 나타낼때는 대부분 이차원 배열 그래프 작업

int n;
int areFriends[10][10] // 여기서 최대 학생수 10
// 최대 경우의 수가 9!가 되므로 이것은 무식하게 푸는 방식인 완전 탐색으로도 풀리는 문제

int countPairing(taken[10]){
	if firstFree = - 1;
	for(int i = 0; i < n; ++i){
		if(!taken[i]){
			firstFree = i;
			break;
		}
	}
	
	// 기저사례(base case) : 모든 학생이 짝을 지은경우 종료
	if(firstFree == -1) return 1;

	// 불변식 : 남은 학생의 수는 항상 짝수 여야한다.
	// A[0...pairwith] 는 짝이 이루어져 있어야 한다.
	int ret = 0;
	for(int pairwith = firstFree + 1; pairwith < n; ++pairwith){
		if(!taken[pairwith] && areFriends[firstFree][pairwith]){
			taken[firstFree] = taken[pairwith] = true;
			ret += countPairing(taken);
			taken[firstFree] = taken[pairwith] = false;
		}
	}

	return ret;
}


// 최대 경우의 수는 9! 이므로 완전 탐색 기법으로도 풀리는 문제이다.