// H * W 크기의 게임판 --> 전역 변수화 xx 각 상태마다 판이 달라야 하므로 안됨
// H * W 크기의 게임판은 매개변수로 보낸다
// 기본적으로 검은 칸과 흰 칸으로 구성되어 있음
// 이 중 모든 흰 칸을 세 칸짜리 L자 모양의 블록으로 덮고 싶음 --> 기저 사례로
// 이 블록은 회전은 가능하지만 서로 겹치거나 검은 칸을 덮거나, 게임판 밖으로 나가면 안됨 --> 기저 사례로 갈 듯
// L자가 덮을 수 있는 방법의 수를 구하라 --> 즉 모든 방법을 시도해봐라 ( 완전 탐색 기법 )

// 입력 첫 줄에는 테스트 케이스의 수 C(C<= 30)
// 테스트 케이스의 첫 줄에는 두개의 정수 H,W (1<=H, W<=20)
// 다음 H 줄에 각 W 글자로 게임판의 모양
// #은 검은 칸, .은 흰칸
// 흰칸의 갯수는 50을 넘지 않는다

// L자 모양은 3개의 칸이 필요하므로 3의 배수가 아니면 성립이 되지 않음 --> 기저 사례


// 재귀함수를 사용하기 위해서는 작은 단위로 쪼개는 작업이 필요하다
// 여기서는 3으로 나눠 한 조각에서 한 블록을 내려 놓도록 하자


// L자가 가능한 모션의 수는 4가지 --> 여기서 쪼개 져야하는 작업
// 이 블럭이 놓일 수 있는가에 대한 확인을 해야한다.
// 만약에 놓을 수 있으면 true로 설정한다.
// 모든 블럭을 돌았을 경우 count를 해서 성공 실패를 알림

// 모든 칸에 블럭을 채웠을 경우 return --> 기저사례
// 블럭은 왼쪽 위 부터 검사함
// 모든 흰 색 칸에 일단 모든 L자를 넣는다 --> 재귀가 필요한 부분
// 놓았던 블럭이 다른 블럭과 겹치치 않은 경우 ok 사인 
// 모든 블럭이 차있고 마지막으로 놓았던 블럭이 ok 일 경우 맞게 넣었다고 생각하고 count
// 다시 넣었던 블럭을 뺀다.

// 최종으로 count했던 수를 새서 return


// 아래는 위의 내용을 기반으로 코딩한 것


// 4가지 모션을 저장한 배열 = 4
// 3개의 칸을 차지함 = 3
// x,y의 좌표 = 2
int moving[4][3][2] = {
    {{0, 0}, {1, 0}, {0, 1}},
    {{0, 0}, {0, 1}, {1, 1}},
    {{0, 0}, {1, 0}, {1, 1}},
    {{0, 0}, {1, 0}, {1, -1}},
};


int countCover(vector<vector<int>>& board){
    // 맨 위에서부터 흰색칸을 찾는다
    int y=-1 , x=-1;
    for(int i=0;i<board.size();++i){
        for(int j=0;j<board[0].size();++j){
            if(board[i][j] == 0){
                y = i;
                x = j;
                break;
            }
        }
        if(y!=-1) break;
    }

    
    // 모든 블럭이 찼을 경우
    if(y==-1) return 1;

    // 4가지 블럭 방향을 가지고 재귀함수를 돌린다.
    // 여기서 일단 모든 흰 블럭을 채우고 나서 이 블럭이 맞았을 경우
    // 맞았을 때 count를 한다
    // 즉 블럭을 넣을 수 있을 때 재귀함수를 호출하는 경우
    int ret = 0;
    for(int type=0;type<4;++type){
        if(set(board,y,x,type,1)){
            countCover(board);
        }
        set(board,y,x,type,-1);
    }

    return ret;
}

int set(vector<vector<int>>& board, int y, int x, int type, int delta){
    bool ok = true;

    // 여기서 경기장 밖으로 나가는 경우를 검사
    // 블럭이 겹치는 경우 검사
    // 블럭이 겹치는 경우는 일단 블럭을 둔 다음에 검사한다.
    for(int i=0;i<3;++i){
        const int ny = moving[type][i][0];
        const int nx = moving[type][i][1];
        
        if(ny < 0 || ny >= board.size() || nx < 0 || nx >= board[0].size()){
            ok = false;
        }else if((board[ny][nx] += delta) > 1){
            // 블럭이 겹쳐져서 놓아졌을 경우
            ok = false;
        }
    }

    return ok;
}